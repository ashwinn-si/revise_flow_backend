# Backend Development Instructions - TaskFlow Server

## Project Context
You are working on the **server** (backend) portion of TaskFlow - a comprehensive Node.js + Express + MongoDB backend for spaced revision reminders. This is a production-ready MERN stack application with complete authentication, task management, and automated reminder systems.

## Technology Stack
- **Runtime**: Node.js with Express.js framework
- **Database**: MongoDB with Mongoose ODM
- **Authentication**: JWT with refresh token rotation
- **Email Service**: NodeMailer with SMTP/AWS SES support
- **Scheduling**: node-cron for automated tasks
- **Validation**: express-validator with sanitization
- **Security**: bcrypt, helmet, rate limiting
- **Logging**: winston with file rotation
- **External APIs**: Google Calendar OAuth2 integration

## Architecture Pattern: MVC
```
src/
├── controllers/     # Route handlers and business logic
├── models/         # Mongoose schemas and database models
├── routes/         # Express route definitions
├── middleware/     # Custom middleware functions
├── services/       # Business services (email, cron, external APIs)
├── utils/          # Utility functions and helpers
├── config/         # Configuration files (db, jwt, email)
├── app.js          # Express application setup
└── server.js       # Server entry point with startup logic
```

## Core Features Implementation

### Authentication System
- **User Registration**: Email verification with 4-character minimum passwords
- **Login System**: Optional 2FA via email OTP
- **Password Reset**: Complete secure token-based flow (request → email → validate → reset)
- **JWT Tokens**: 15-minute access tokens + 30-day refresh tokens with rotation
- **Account Security**: Login attempt limiting, account locking, token blacklisting

### Task Management
- **CRUD Operations**: Create, read, update, delete tasks with proper validation
- **Spaced Revision System**: Automatic scheduling (default 3rd & 7th day revisions)
- **Revision Tracking**: Completion status, postpone functionality, rescheduling
- **Archive System**: Soft delete with restore capability
- **Statistics**: User progress tracking and analytics

### Automated Services
- **Daily Reminders**: 6:00 AM timezone-aware email notifications
- **Weekly Summaries**: Sunday progress reports
- **Token Cleanup**: Automated expired token removal
- **Graceful Shutdown**: Proper cleanup of cron jobs and database connections

### Email System
- **HTML Templates**: Professional branded email templates
- **Multiple Types**: Verification, 2FA codes, password reset, daily reminders
- **SMTP Support**: Gmail, AWS SES, or custom SMTP providers
- **Template Variables**: Dynamic content with user-specific data

## Development Guidelines

### Code Structure
```javascript
// Example controller structure
const exampleController = {
  // GET endpoint
  getResource: async (req, res, next) => {
    try {
      // Input validation
      const { id } = req.params;
      
      // Business logic
      const resource = await ResourceModel.findById(id);
      if (!resource) {
        return res.status(404).json({ 
          success: false, 
          message: 'Resource not found' 
        });
      }
      
      // Success response
      res.status(200).json({
        success: true,
        data: resource
      });
    } catch (error) {
      next(error); // Let error handler middleware deal with it
    }
  }
};
```

### Database Design Principles
1. **Indexing**: Compound indexes for query optimization
2. **Validation**: Mongoose validators with custom error messages
3. **Relationships**: Embedded documents for related data (revisions in tasks)
4. **Virtual Fields**: Computed properties for UI consumption
5. **Static Methods**: Complex queries encapsulated in model methods

### Security Implementation
```javascript
// Example middleware usage
app.use(helmet()); // Security headers
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 })); // Rate limiting
app.use(cors({ origin: process.env.CLIENT_URL, credentials: true })); // CORS
app.use('/api/auth', authRouter); // Authentication routes
app.use('/api/tasks', authenticateToken, tasksRouter); // Protected routes
```

### Error Handling Pattern
```javascript
// Global error handler middleware
const errorHandler = (err, req, res, next) => {
  logger.error('Error occurred:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip
  });
  
  // Mongoose validation errors
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Validation error',
      errors: Object.values(err.errors).map(e => e.message)
    });
  }
  
  // Default server error
  res.status(err.status || 500).json({
    success: false,
    message: err.message || 'Internal server error'
  });
};
```

## API Design Standards

### Response Format
```javascript
// Success response
{
  "success": true,
  "data": { /* response data */ },
  "message": "Optional success message"
}

// Error response
{
  "success": false,
  "message": "Error description",
  "errors": ["Detailed error array if applicable"]
}
```

### Endpoint Conventions
- **RESTful URLs**: `/api/tasks/:id/revisions/:revisionId`
- **HTTP Methods**: GET (read), POST (create), PUT (update), DELETE (remove), PATCH (partial update)
- **Status Codes**: 200 (success), 201 (created), 400 (validation), 401 (unauthorized), 404 (not found), 500 (server error)
- **Pagination**: `?page=1&limit=10&sort=createdAt&order=desc`
- **Filtering**: `?status=pending&category=work&search=keyword`

### Authentication Middleware
```javascript
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ 
        success: false, 
        message: 'Access token required' 
      });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId).select('-password');
    
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid token' 
      });
    }
    
    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ 
      success: false, 
      message: 'Invalid token' 
    });
  }
};
```

## Environment Configuration

### Required Variables
```env
# Database
MONGO_URI=mongodb://localhost:27017/taskflow

# JWT Authentication
JWT_SECRET=your-super-secure-256-bit-secret
JWT_REFRESH_SECRET=your-refresh-token-secret
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=30d

# Email Service
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=true
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password
FROM_EMAIL=noreply@taskflow.com

# Server Configuration
NODE_ENV=development
PORT=5000
CLIENT_URL=http://localhost:3000

# Optional Integrations
GOOGLE_CLIENT_ID=your-google-oauth-client-id
GOOGLE_CLIENT_SECRET=your-google-oauth-secret
GOOGLE_REDIRECT_URI=http://localhost:5000/api/google/callback
```

### Production Environment (AWS)
```env
# Critical for AWS deployment
TZ=UTC

# Database (MongoDB Atlas recommended)
MONGO_URI=mongodb+srv://username:password@cluster.mongodb.net/taskflow

# AWS SES Email Service
SMTP_HOST=email-smtp.us-east-1.amazonaws.com
SMTP_PORT=587
SMTP_USER=your-ses-smtp-username
SMTP_PASS=your-ses-smtp-password

# Production URLs
CLIENT_URL=https://your-frontend-domain.com
```

## Cron Jobs & Automated Tasks

### Daily Reminder System
```javascript
// 6:00 AM daily reminders in user's timezone
cron.schedule('0 */1 * * *', async () => { // Every hour
  const users = await User.find({ 
    isEmailVerified: true,
    emailNotifications: true 
  });
  
  for (const user of users) {
    const userTime = moment().tz(user.timezone);
    if (userTime.hour() === 6) {
      await sendDailyReminders(user);
    }
  }
});
```

### Graceful Shutdown
```javascript
// In server.js - handle graceful shutdown
const gracefulShutdown = (signal) => {
  logger.info(`\n${signal} received. Shutting down gracefully...`);
  
  // Stop cron jobs
  stopScheduledJobs();
  
  // Close server
  server.close(async () => {
    // Close database connection
    await mongoose.connection.close();
    process.exit(0);
  });
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
```

## Database Optimization

### Indexing Strategy
```javascript
// User model indexes
userSchema.index({ email: 1 }, { unique: true });
userSchema.index({ resetPasswordToken: 1 });
userSchema.index({ emailVerificationToken: 1 });

// Task model indexes
taskSchema.index({ userId: 1, createdAt: -1 });
taskSchema.index({ userId: 1, isArchived: 1, 'revisions.dueDate': 1 });
taskSchema.index({ 'revisions.dueDate': 1, 'revisions.isCompleted': 1 });
```

### Query Optimization
```javascript
// Efficient task queries with population
const getTasks = async (userId, page = 1, limit = 10) => {
  return await Task.find({ 
    userId, 
    isArchived: false 
  })
  .sort({ createdAt: -1 })
  .limit(limit * 1)
  .skip((page - 1) * limit)
  .lean(); // Use lean() for read-only queries
};
```

## Integration Patterns

### Google Calendar OAuth
```javascript
// Complete OAuth2 flow implementation
const initiateGoogleAuth = (req, res) => {
  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI
  );
  
  const authUrl = oauth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: ['https://www.googleapis.com/auth/calendar'],
    state: req.user._id.toString()
  });
  
  res.redirect(authUrl);
};
```

### Email Templates
```javascript
// Dynamic email template rendering
const generateEmailHTML = (template, variables) => {
  let html = fs.readFileSync(`templates/${template}.html`, 'utf8');
  
  // Replace template variables
  Object.keys(variables).forEach(key => {
    const regex = new RegExp(`{{${key}}}`, 'g');
    html = html.replace(regex, variables[key]);
  });
  
  return html;
};
```

## Testing Guidelines
- Unit tests for utility functions and models
- Integration tests for API endpoints
- Mock external services (email, Google APIs)
- Test error scenarios and edge cases
- Database cleanup between tests

## Performance Monitoring
- Winston logging with structured output
- Request/response time tracking
- Database query performance monitoring
- Memory usage and cleanup verification
- Cron job execution tracking

## Deployment Considerations
- Use PM2 for process management in production
- Set up log rotation for winston logs
- Configure MongoDB connection pooling
- Implement health check endpoints
- Set up monitoring and alerting
- Use environment-specific configurations

## Common Development Tasks

### Adding New API Endpoints
1. Define route in appropriate router file
2. Create controller function with proper validation
3. Add middleware if needed (auth, validation)
4. Update API documentation
5. Write tests for new endpoint

### Database Schema Changes
1. Update Mongoose model with new fields
2. Add proper validation and indexes
3. Create migration script if needed
4. Update related controllers and services
5. Test with sample data

### Email Template Updates
1. Modify HTML template in templates directory
2. Update template variables if needed
3. Test email rendering and delivery
4. Ensure mobile responsiveness
5. Update related service functions

## Security Best Practices
1. **Input Validation**: Validate and sanitize all user inputs
2. **Authentication**: Implement proper JWT token management
3. **Authorization**: Check user permissions for resource access
4. **Rate Limiting**: Prevent abuse with request throttling
5. **Data Encryption**: Hash passwords, encrypt sensitive data
6. **CORS Configuration**: Restrict cross-origin requests appropriately
7. **Security Headers**: Use helmet.js for security headers
8. **Environment Variables**: Never commit secrets to version control

## Debugging and Troubleshooting
- Use winston logs for debugging information
- Set up proper error tracking and monitoring
- Implement request ID tracking for tracing
- Use MongoDB query profiling for performance issues
- Monitor memory leaks and cleanup resources properly